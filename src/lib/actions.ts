'use server';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';
import { initializeFirebase } from '@/firebase';
import { collection, addDoc, doc, updateDoc } from 'firebase/firestore';
import { addDocumentNonBlocking, updateDocumentNonBlocking } from '@/firebase/non-blocking-updates';

// Schema for creating a new module (ID is not included as it's generated by Firestore)
const addModuleSchema = z.object({
  yard: z.string().min(1, 'Yard is required.'),
  location: z.string().min(1, 'Location is required.'),
  moduleNo: z.string().min(1, 'Module No. is required.'),
  rfloDate: z.string().optional(),
  shipmentNo: z.string().optional(),
  rfloDateStatus: z.enum(['Date Confirmed', '1st Quarter-2026', 'Pending']),
  yardReport: z.string().optional(),
  islandReport: z.string().optional(),
  signedReport: z.boolean().optional(),
});

// Schema for updating an existing module (ID is required)
const updateModuleSchema = addModuleSchema.extend({
  id: z.string().min(1, 'ID is required.'),
});


export async function updateModule(data: z.infer<typeof updateModuleSchema>) {
  const validation = updateModuleSchema.safeParse(data);
  if (!validation.success) {
    return {
      success: false,
      error: validation.error.flatten().fieldErrors,
    };
  }

  try {
    const { firestore } = initializeFirebase();
    const { id, ...moduleData } = validation.data;
    const moduleRef = doc(firestore, 'modules', id);
    await updateDoc(moduleRef, {
      ...moduleData,
      signedReport: moduleData.signedReport ?? false,
    });
    revalidatePath('/');
    return { success: true, data: { id, ...moduleData } };
  } catch (e: any) {
    return { success: false, error: { _form: [e.message] } };
  }
}

export async function addModule(
  data: z.infer<typeof addModuleSchema>
) {
  const validation = addModuleSchema.safeParse(data);
  if (!validation.success) {
    return {
      success: false,
      error: validation.error.flatten().fieldErrors,
    };
  }

  try {
    const { firestore } = initializeFirebase();
    const newModuleData = {
        ...validation.data,
        signedReport: validation.data.signedReport ?? false,
    };
    const modulesCollection = collection(firestore, 'modules');
    await addDoc(modulesCollection, newModuleData);
    
    revalidatePath('/');
    return { success: true, data: newModuleData };
  } catch (e: any) {
    return { success: false, error: { _form: [e.message] } };
  }
}
